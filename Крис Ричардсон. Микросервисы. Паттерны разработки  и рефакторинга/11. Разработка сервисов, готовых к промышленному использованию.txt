Нужно обеспечить три характеристики:
- безопасность
- конфигурируемость
- наблбдаемость 

У микросервисов и монолитом много общего в плане обеспечения безопасности, но есть и различия. 
	В микросервисной архитектуре надо реализовать механизм для безопасной передачи пользовательских данных от одного сервиса к другому.

Должен быть внешний механизм, который предоставляет сервису конфигурации на этапе выполнения

Четыре аспекта безопасности:
- аутентификация - проверка подлинности человека или программы, проверяем айдишник, пароль или токен
- авторизация - проверяем, можно ли субъект совершать запрошенную операцию с данными, используются роли
- аудит - отслеживаем операции, выполняемые субъектом.
- безопасное межпроцессное взаимодействие - в идеале любое взаимодействие внутри сервисов и за пределами должно идти через tls

Традиционная реализация аутентификации - клиент входит в систему с логином и паролем, которые шлёт пост-запросом, 
	в ответ после проверки создаётся сеанс и сохраняется информация о субъекте. Клиенту отдаётся токен, 
	который включает во все следующие запросы, напр с куками. Каждый запрос обрабатывается перехватчиком, 
	который производит аутентификацию, проверяя токен сеанса и устанавливая контекст безопасности, 
	который описывает субъекта и его роли. С помощью контекста определяется, можно ли клиенту выполнять операцию.

Микросервисная архитектура распределенная и каждый запрос обрабатывается, как минимум, апи шлюзов и минимум одним сервисом. 
	Нужно определиться, кто овечает за аутентификацию пользователя, а кто - за авторизацию. 
	В микросервисах нельзя исп контекст безопасности в ОЗУ и централизованный сеанс.

Аутентификацию лучше делать на уровне апи шлюза - он аутентифицирует юзера, как описано выше, 
	и отдаёт токен с информацией о пользователе, включая его идентификатор и роли, сервисам, к которым тот обращается. 
	А сервисы уже проверяют токен каждый на своём уровне.

Авторизацию тоже можно реализовать на уровне апи шлюза, открыв доступ к определённым эндпойнтам только тем юзерам, 
	у которых есть права. Плюс - централизованное решение снижает р им а уязвимостей. Минус - риск привязки апи шлюза к сервисам. 
	Поэтому авторизацию, где участвует доменная логика, реализовать лучше в рамках сервисов.

Нужно решить, с помощью какого токена шлюз будет передавать инфу о юзере сервисам:
- не прозрачные токены формата uuid. Минус - снижение доступности, производительности, увеличение латентности, 
	тк надо делать синхронные запросы к сервису безопасности для проверки токенов и получения инфы о юзере
- прозрачные токены - содержат данные юзера, напр, JWT. Содержит json с данными о юзере, зашифрованный ключом, 
	известным только его создателю, напр, апи шлюзу, и получателю, напр, сервису. 
	Минус - нельзя отозвать токен в случае компрометации, потому ставят малые сроки годности. 
	Эти проблемы решены в стандарте безопасности OAuth 2.0.

Три ключевых принципа:
- апи шлюз отвечает за аутентификацию клиентов
- апи шлюз и сервисы задействуют прозрачные токены для обмена информацией о субъекте безопасности
- сервис использует токен для получения учётных данных и ролей субъекта

Конфигурация, вынесенная вовне - предоставляет запущенному сервису значения конфига, а не конфиг пишется прямо в коде.

Есть два подхода:
- пассивная модель - инфраструктура развёртывания передаёт сервису конфиг, используя конфиг файл или переменные окружения. 
	Минус - сложно или невозможно менять конфиг уже запущенного сервиса. 
- активная модель - сервис сам берет конфиг с сервиса конфигурации. Конфиг для доступа к серверу конфигов предоставляется 
	по пассивной модели.

Сервис конфигурации - можно исп систему управления версиями, напр, гит, базу данных или специальный сервер конфигурации.

Плюсы использования сервера конфигурации:
- централизованная конфигурация
- прозрачная расшифровка конфиденциальных данных
- динамическое изменение конфига

Минусы:
- Ещё один сервер, который нужно обслуживать и настраивать

Шаблоны проектирования наблбдаемых сервисов:
- апи проверки работоспособности - эндпойнт, который возвращает данные о работоспособности сервиса
- агрегация журналов - ведёт журналы активности сервисов и сохраняет на центральном сервисе с поддержкой поиска и нотификаций
- распределенная трассировка - у каждого запроса есть айдишник, и можно отслеживать запросы по мере их перемещения между сервисами
- отслеживание исключений - за ними следит отдельный сервис, который оповещает разрабов
- метрики приложения - сервисы собирают метрики и оценочные показатели и передают сервису метрик
- ведение журнала аудита - ведёт журнал действий пользователей. Популярное решение - ELK стек. Elasticsearch - бд для хранения логов, 
	logstash - конвейер для агрегации журналов и отправки в Elasticsearch, kibana - инструмент визуализации для Elasticsearch

Распределенная трассировка - назначает каждому внешнему запросу уникальный айдишник и отправляет данные о его перемещениях 
	по системе от одного сервиса к другому на центральный сервер, напр, open zipkin или aws x-ray, 
	который предоставляет визуализацию и возможность анализа.

Отслеживание исключений - сервис сообщает об исключения центральному сервису, которых их дедуплицирует, 
	отслеживает их исправление и генерирует оповещения.

Шаблон Шасси микросервисов (microservice chassis) - создание сервисов на основе фреймворка или набора фреймворков, 
	которые реализуют такое общие функции, как отслеживание исключений, ведение журнала, проверка работоспособности, 
	работа с внешним конфигом и Распределенная трассировка. Упрощает создание и настройку всего того, о чем говорилось выше, 
	чтобы сосредоточиться на реализации бизнес логики. Примеры - go kit и Micro для go, spring cloud для java и тд. 
	Минус - для каждого языка требуется свое шасси.

Сеть сервисов (service mesh) - пропускает весь трафик между сервисами через сетевой слой, реализующий такие функции, 
	как Предохранитель, распред. трассировка, обнаружение сервисов, балансироварие нагрузки и маршрутизации трафика с учётом правил. 
	Примеры - istio, linkerd, conduit. Плюсы - освобождает разработчиков от реализации общих функций.