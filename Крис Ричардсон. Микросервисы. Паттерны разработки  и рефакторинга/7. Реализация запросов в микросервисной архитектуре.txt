В монолите одним запросом можно извлечь сразу много данных, но в к микросервисах бывает так, 
	что нужные для ответа данные раскиданы по разным сервисам. Это проблема. 

Есть два шаблона для написания запросов в микросервисной архитектуре :
- объединение API (API composition) - самый простой, юзаем всегда, когда можно. 
	За обращение к сервисам и объединение результатов отвечают клиенты
- разделение ответственности командных запросов (CQRS) - больше возможностей, но сложнее, требует наличия нескольких бд, 
	которые отвечают только за поддержку запросов.

Объединение API

API - композитор - реализует операцию запроса, обращаясь к сервисам-провайдерам, затем объединяет полученные результаты. 
	Это может быть клиент, напр, веб приложение, или сервис, напр, апи шлюз. 
Сервис-провайдер - сервис, которому принадлежат данные, возвращаемые запросом

Можно ли использовать этот шаблон, зависит от вида декомпозиции данных по сервисам. Иногда это неэффективно, 
	тк надо объединять большие объёмы данных в памяти. 

Проблемы объединения апи:
- надо решить, какой компонент будет выступать апт-композитором для операции запроса
- как написать эффективную логику агрегации?

Первый вариант апи-композитора - клиент, напр, веб приложение. Но это может быть плохо из-за брандмауэров или медленной сети. 
Второй вариант - апи шлюз, реализующий внешний апи приложения. Этот вариант подходит для запросов, которые входят в состав внешнего апи. 
Третий вариант - отдельный сервис. Этот вариант следуют использовать для апи внутри сервисов или для внешних запросов, 
	чья логика слишком сложная чтобы делать её частью апи шлюза. 

В идеале запросы к сервисам провайдерам должны распараллеливаться, если это возможно. 

Плюсы объединения апи:
- простота

Минусы:
- доп накладные расходы на объединение данных и запросы к разным сервисам
- риск снижения доступности, если есть запросы, зависящее от результатов других запросов и от большого количества вовлеченных сервисов. 
	В случае недоступности можно отдавать кэшированные данные или отдавать только часть данных клиенту
- нехватка транзакционного согласованности данных, тк запросы выполняются не в рамках одной транзакции. 
	Апи композитор должен решать проблемы рассогласования

CQRS (command query responsibility segregation) 

Реализует запрос, которому нужны данные из нескольких источников. Для поддержания представления, 
	реплицирующего данные из разных источников и доступного только для чтения, используют события. 

Задействует одно или несколько представлений бд, которые реализуют как минимум один запрос приложения

Существуют запросы, которые трудно реализовать объединением апи или просто невозможно, напр, 
	запрос истории заказов с фильтрацией по атрибутам, которые есть только у некоторых сервисов, а у других их нет. 
	Это можно решить объединением результатов в памяти на уровне апи композитора, но для этого надо извлекать и обрабатывать 
	большие объёмы лишних данных. Второй пример сложного запроса - геопространственный поиск, напр, 
	найти доступные рестораны на опред расстоянии от адреса доставки. Если не исп спец типы, а-ля location для postgres, 
	то запрос будет медленный и надо будет обрабатывать на сервисе. Либо хранить эти данные в другой базе с поддержкой 
	геопространственных запросов. Cqrs позволяет хранить копию данных с отложенный согласованностью.