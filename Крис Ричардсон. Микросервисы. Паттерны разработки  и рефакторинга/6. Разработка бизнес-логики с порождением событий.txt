Шаблон Порождение событий сохраняет агрегат в виде последовательности доменных событий, которые представляют изменения состояния.

Плюсы:
- сохранение истории изменений для аудита или других задач
- надёжная публикация доменных событий, что полезно в микросервисной архитектуре

Минусы:
- сложность, это совершенно другой способ написания бизнес логики
- обращение к хранилищу событий часто затруднено, нужно использовать cqrs

Проблемы традиционного сохранения данных:
- объектно-реляционный разрыв - концептуальное несоответствие между реляционной схемой в бд и графовой структурой доменной модели 
	со сложными отношениями 
- отсутствие истории агрегатов
- сложное журналирование чревато ошибками
- публикация событий является лишь дополнением к бизнес логике

Порождение событий решает эти проблемы.

Порождение событий - это событийный подход к реализации бизнес лоники и сохранению агрегатов. 
	Агрегат хранится в базе в виде цепочки событий, каждое событие представляет изменение его состояния.

При загрузке агрегата из базы приложение создаёт его экземпляр и последовательно перебирает события, приводя состояние к актуальному.

При использовании этого подхода бизнес логика и события связаны вместе, и события генерируется всегда. 
	Каждое изменение агрегата генерирует событие.

Командные методы, работающие с агрегатом, генерируют события, которые кладутся в базу и применяются к агрегату

Часто два или более запроса одновременно обновляют один агрегат. В этом случае можно исп столбец с версией, и по нему проверять, 
	обновил ли кто-то агрегат с тех пор, как он был считан ( просто where по равенство версий в запросе). 
	Это оптимистическое блокирование

Сохранение события в хранилище - атомарная операция

Издатель может опрашивать хранилище на предмет новых записей, а затем публиковать их брокеру сообщений. 
	При выборке надо проверять, что события не были опубликованы, тк иначе конкурирующие транзакции могут вызвать рассогласование

Со временем события накапливаются - увеличивается время обработки долгоживущих агрегатов. 
	Эту проблему решают с помощью периодического сохранения снимков состояния - приложение грузит снимок и те события, 
	что были после него, а не все события ща все время.

Необходимо также обеспечить идемпотентность, игнорируя дубликаты событий

Формат событий со временем может меняться. Каждое структурное изменение представлено миграцией в бд

Плюсы продления событий:
- надёжная публикация доменных событий
- сохранение истории изменений
- отсутствие большинства проблем, связанных с объектно-реляционным разрывом

Минусы:
- высокий порог вхождения и другая модель программирования
- так же сложно, как и приложение, основанное на обмене сообщениями
- изменения событий могут создать проблемы
- усложнение удаления данных, напр, если нужно удалить личные данные, хранящиеся в событиях. 
	В этих случаях можно хранить отдельно ключ шифрования юзера и удалять его, а не данные в событии, 
	тк все равно расшифровать их будет нельзя

- обращение к хранилищу связано с определёнными трудностями