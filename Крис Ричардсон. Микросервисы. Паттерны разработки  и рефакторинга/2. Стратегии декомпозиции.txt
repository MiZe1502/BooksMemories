Архитектура приложения - это его декомпозицич на части и связи между ними

Архитектуры вида 4 + 1:
- логические компоненты - то, что создают прогеры
- представление реализации - результат сборки системы
- представление процесса - компоненты на этапе выполнения
- развёртывание - то, как процессы распределяются по устройствам
- плюс сценарии, которые оживляют представления

Многоуровневая архитектура: уровни представления, бизнес-логики, хренения данных. 
Плохо, что единые уровни и бизнес уровень зависит от хранения данных.

Шестигранная архитектура лучше - есть набор входящих адаптеров, которые обрабатывают внешние запросы вызовами бизнес логики. 
	Плюс - бизнес логика отделена адаптерами от представления и доступа к данным => легко тестировать, 
	более точное отражение архитектуры по, хорошо подходит для микросервисов

Микросервисная архитектцра структурирует приложение в виде набора слабо связанных сервисов, 
	которые развертываются независимо друг от друга. 

Сервис - это автономный, независимо развертываемый программный компонент, который реализует определённые полезные функции.

API сервиса инкапсулирует его внутреннюю реализацию => обеспечивается модульность через слабую связность => ускорение разработки, 
	улучшение поддержки и тестирования. Минус - сложнее строить запросы и синкать данные в разных бд

В общие либы лучше выносить редко изменяемые функции, иначе придётся пересобирать и развертывать все зависимые сервисы

Размер сервиса не имеет значения, имеет значение размер команды, которая делает сервис. Одна команда - один сервис

Определение архитектуры:
Шаг1. Определяем операции, выполняемые системой на основе требований и юзер сторей
Шаг2. Определяем сервисы
Шаг3. Определяем API и взаимодействие сервисов

Операции определяются на основе требований. На первом шаге - доменная модель, обобщенные классы сущностей, 
	на втором - в рамках модели определяются операции над сущностями

Декомпозиция возможна по бизнес возможностям, которые определяются тем, чем занимается организация, тем из чего генерируется прибыль. 
	Это стабильные вещи в отличие от того, как организация ведёт бизнес.

Каждую возможность можно представить в виде сервиса и разбить на подвозможности. Сервисы создаются как для возможностей целиком, 
	напр, для бухучета и отчётности, так и для подвозможностей отдельно. Разбиение зачастую субъективно.

Плюсы: возможности стабильны => архитектура получается довольно стабильной
Минусы: может получиться излишнее межсервисное взаимодействие

Второй вид разбиения - по проблемным областям, определяет сервисы в соответствии с поддоменами в DDD

DDD разбивает одну огромную доменную модель на отдельные, соответствующие поддоменам. 
	Разбиение происходит по тем же принципам, что и определение бизнес-возможностей 

Область применения доменной модели - изолированный контекст

DDD хорошо ложится на микросервисы, та же концепция автономных команд, плюс отдельные модели хорошо борются с божественными классами

Некоторые подходы из ооп тоже полезны для Декомпозиции - принцип единственной ответственности и принцип согласованного изменения. 
	ПСИ хорошо борется с распределенным монолитом

Трудности пр Декомпозиции:
- латентность сети - нагрузка на сеть возрастает, если пересылается много данных
- ухудшение доступности из-за синхронного взаимодействия, могут быть проблемы, если какой-то из сервисов недоступен 
- необходимо поддерживать согласованность сервисов
- получение согласованного представления данных
- божественные классы, препятствующие Декомпозиции, лучший вариант - своя доменная реализация класса для каждого сервиса. 
	Для связи с общим пользовательский интерфейсом часто юзают апи шлюз

Определение API:
- назначаем сервисам операции
- определяем, какие взаимодействие между сервисами требуется для выполнения каждой из них, и дополняем сервисы этими методами апи
- решаем, какой технологией будет реализовано апи, какие сервисы будут автономными и вместо синхронных запросов к другим сервисам 
	будут хранить копию данных и подписываться на их обновления