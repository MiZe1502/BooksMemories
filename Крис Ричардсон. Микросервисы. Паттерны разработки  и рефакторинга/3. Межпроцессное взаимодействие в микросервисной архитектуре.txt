Выбор механизма взаимодействия - важное архитектурные решение, которое может повлиять на доступность всего приложения

Перед выбором механизма взаимодействия нужно подумать о стиле взаимодействия между сервисом и клиентамип: 
	один к одному или один ко многим, так же синхронное или асинхронное

Один к одному:

Запрос/ответ - послали запрос, ждём ответ, можем заблокироваться. Приводит к жёсткой связности. 
	Асинхронный вариант уберегает от блокировки.

Однонаправленные уведомления - шлем запрос, но не ждём ответ.

Один ко многим:

Издатель/подписчик - клиент шлёт сообщение, которое ловят все заинтересованные сервисы

Издатель/асинхронные ответы - клиент публикует сообщение с запросом и ждём определенное время ответа от сервисов

Считается в том числе, что описание сервиса должно начинаться с его апи, и только после согласования должен создаваться сам сервис

Апи неизбежно изменяется со временем. При нумерации версий часто используют семантическое версионирование вида Major.Minor.Patch. 
Мажорную версию можно использовать, как первый компонент урла, если сообщения - то передавать в сообщении 

Всё изменения в идеале должны быть обратно совместимыми. 

Мажорные изменения - меняем префикс v1, v2 и тд или как-то передаём в сообщении 

Нужно осторожно выбирать формат сообщений, не привязываться к конкретному языку 

Форматы: текстовые (json, xml), двоичные (protobuf, avro, thrift). Текстовые менее производительны, долго парсить.

Удалённый вызов процедур - клиент обращается к сервису по синхронному протоколу на основе удалённого вызова процедур, 
такому, как REST. Коммуникационных протоколов много, есть ещё gRPC. 

REST
- ресурс - ключевая концепция 
- часто на основе http, но не всегда 
- get для получения данных, post для отправки, put для обновления.
- соответствие рест можно оценить по модели зрелости - уровень 0 - все через пост запросы, указываем действие,цель, параметры , 
	уровень 1 - то же самое, но без цели, уровень 2 - разделение на гет, пост, пут, 
	уровень 3 - получаем ссылки для выполнения действий по гет запросу ресурса
- для описания рест используют open API specification, напр в swagger
- минусы - сложно получить одним запросом много связанных объектов, тк стандарт ориентирован на то, что 
	один запрос - один ресурс => увеличивается время отклика. Можно позволить извлекать связанные ресурсы. 
	Из-за этого популярен, напр, graphql, рассчитанный на эффективное извлечение данных. 
	Так же иногда сложно привязать к http командам несколько операций обновления 
- Плюсы : прост, легко тестировать, http дружествен, не нуждается в промежуточном брокере

gRPC:
— Это двоичный протокол на основе сообщений и фреймворк для написания клиента и сервера, апи описывается через протобаф, 
	обмен идёт сообщениями в формате протобаф по http/2
- состоит из описания сервисов и сообщений вида запрос-ответ
- плюсы: легко реализовать разные операции обновления, позволяет легко сохранять совместимость, легко описывать
- минусы - работы с фронта сложнее, старые брандмауеры могут не поддерживать http/2

Но у обоих протоколов есть проблема частичного отказа. 

Шаблон Предохранитель - прокси, который в случае достижения определённого лимита послкдовательных отказов начинает отклонить все вызовы, 
	пока не истечёт опрелеленное время 

- никогда не блокироваться бессрочно, всегда пусть будет таймаут
- ограничивает количество неудачных запросов от клиента серверу 
- шаблон предохранитель - если превысили порог, размыкаем предохранитель, чтобы следующие попытки сразу завершались

Восстановление после отказа:
- можно вернуть клиенту ошибку, либо значение по умолчанию или зарезервированное значение

Другая проблема - чтобы один сервис мог вызвать процедуры из другого, он должен знать местоположение конкретного экземпляра сервиса в сети. 
	Нужен механизм обнаружения сервисов

В обычной ситуации можно было бы юзать для этого конфиги, но в облаке все сложнее и динамичнее, тк много отказов, 
	обновлений и масштабирование.

Используем реестр сервисов - базу данных, с инфой о том, где находятся сервисы. 
	Работаем с ним напрямую или через инфраструктуру развёртывания.

Клиент сперва дёргает реестр, а затем сервис по полученному адресу или одному из адресов. 
	При включении каждый сервис дёргает апи реестра и регистрирует себя там - шаблон саморегистрации. 
	Так же может дать урл, который реестр дёргает по таймеру для проверки работы сервиса, либо сервисы дёргают хартбит реестра, 
	сообщая о своей работоспособности

Минус - нужны либы для работы с реестром для каждого языка и нужно обеспечивать работу реестра, 
	что требует своих затрат времени и ресурсов. Поэтому можно исп встроенные в инфраструктуру средства. 
	Такие есть у докера, кубернетеса и тд.

В этом случае исп шаблон Сторонняя регистрация - сервис регистрируется в реестре сторонним компонентом 
	и шаблон Обнаружение на стороне сервера - клиент дергает маршрутизатор, которые отвечает за обнаружение сервиса. 
	Плюсы - за все отвечает платформа, минусы - обнаруживаются только сервисы в рамках платформы. 
	Но лучше использовать именно этот вариант.

Шаблон Обмен сообщениями - клиент общается с сервисом посредством асинхронных сообщений. 
	Часто используется брокер сообщений,но можно и напрямую.

Сообщение содержит заголовок и тело. В заголовке адреса. Сообщение могут быть документом, содерж только данные, командой и событием

Сообщения передаются по каналам, абстракциям. Много отправителей - много потребителей.

Виды каналов: точка-точка и Издатель-подписчик.

Обмен сообщениями - очень гибок, по природе своей асинхронен.

Точка-точка: Клиент шлёт в сообщении айди ответного канала, а сервис в ответ - айдишник соответствия исходному сообщению, 
	чтобы клиент мог смаппить ответ.

Издатель - подписчик : клиент публикует в канале сообщение, которое считывает несколько потребителей. 
	Исп для уведомлений в основном, напр, по вебсокетам. Потребитель может слать что-то в ответ, тогда нужен айди ответного канала

Брокер сообщений
- чаще используют, чем нет
- чаще лучше с ним, чем без
- без брокера сервисы общаются напрямую (ZeroMQ). Меньше трафика, нет узкой точки в виде брокера, не нужно настраивать брокер. 
	Но минусы - сервисы должны знать друг о друге, меньше доступность, труднее реализация
- с брокером важно учитывать порядок следования сообщений и масштабируемость, гарантии доставки, латентность и поддерживаемые языки
- плюсы брокера: меньше связность, буферизация сообщений, гибкость.
- минусы брокеров: узкое место, единая точка отказа, сложность в администрировании

Проблема - конкурирующие получатели могут получить сообщения не в том порядке. Решение - сегментированные каналы. 
	Содержат два или больше сегментов, которые сами, как канал, сообщения идут в конкретный сегмент, 
	а брокер группирует всех конкурирующих получателей по сегментам и общается с ними, как с одним общим.

Проблема - дублирование сообщений при отказе или проблемах с сетью. 
	Решение - добавление в сообщение идемпотентных дескрипторов (чтобы одни и те же входные данные не имели доп эффектов) 
	или отслеживание и отклонение дубликатов (напр, потребитель сохраняет в базе все обработанные айдишники сообщений 
	и проверяет по ним)

Чтобы избежать не согласованного состояния исп распределенные транзакции, охватывающие и брокер, и приложение, 
	но для современных приложений это не хорошее решение.

Потому исп таблицы бд в качестве очереди сообщений - шаблон Публикация событий, в рамках транзакции по обновлению бд 
	сервис сохраняет сообщение в таблицу outbox, а ретранслятор сообщений считывает ее и передаёт брокеру.

Шаблон Опрашивающий Издатель - ретранслятор время от времени опрашивает базу и публикует новые сообщения брокеру, 
	а затем удаляет их из базы. Но это затратно.

Шаблон Отслеживание транзакционного журнала - то же самое, но анализатор отслеживает изменения в журнале транзакция, 
	формирует сообщения и отправляет брокеру

REST - плохо для взаимодействия микросервисов, ухудшает доступность, тк синхронный протокол, и сервисы должны быть доступны

Доступность зависимых сервисов - произведение доступностей.

Если у сервиса есть синхронный апи, доступность можно улучшить за счёт репликации данных - сервис хранит копию данных, 
	необходимых для ответа на запросы и не лезет в другие сервисы, но тогда надо подписываться на события, 
	публикуемые сервисами, которым эти данные принадлежат. Иногда это ок, сервис получается автономным. 
	Минус - копируем много данных и это не решает проблему обновления данных, принадлежащих другим сервисам.

Другой вариант - отсроченное выполнение. Сервис обновляет свои локальные данные и возвращает ответ, 
	не обращаясь никуда в другие сервисы, а только шлёт им асинхронные сообщения, по ответам которых сервис модифицирует данные. 
	Плюс - слабая связность сервисов и то, что не все сервисы должны быть доступны в конкретный момент. 
	Минус - сложность клиента, чтобы получать обновления о статусе запроса