Каждый слой модели данных инкапсулирует сложность нижележащих слоев. Благодаря таким абстракциям становится возможной 
	слаженная работа разных групп людей. 

Sql доминировал десятки лет, и сейчас большая часть инета построена на реляционных бд

NoSql появился по причинам:
- потребность в лучшем масштабировании и обработке очень больших данных 
- опенсорс лучше проприетарного по
- специализированные запросные операции 
- ограниченность реляционных схем

У каждого приложения свои требования и оптимальная технология может отличаться в зависимости от сценария использования 

Минус реляционных бд - объектной реляционное несоответствие, когда модели в коде отличаются от представления на уровне базы, 
	где много разных таблиц и отношений

Представление данных в виде json документа снижает рассогласованность, лучше локальность, чем у многотабличной схемы. 
	Но в документную модель плохо вписываются связи много-ко-многим и соединения, и приходится их реализовывать в коде приложения 
	несколькими запросами к бд

Сетевая модель - канула в лету, представляла собой что-то вроде графа, у каждой записи могло быть много родительских записей. 
	Код запросов был не гибким и медленным. 

Реляционная модель - простые таблицы и кортежи, данные лежат на виду, участие оптимизаторов запросов и индексов, простые запросы, 
	лучшая поддержка соединений и связи многие ко многим и многие к одному. 

Документоориентированнная модель - возврат к иерархической модели, но с сохранением записей один ко многим. 
	Но со многими ко многим по прежнему проблемы. Зато гибкая схема, лучшая производительность и большая близость к применяемым 
	структурам данных. 

Если структура данных в приложении древовидная, то исп документную модель, тк для реляционного разложения данных по таблицам может 
	получиться очень запутанная схема. Но если есть связи многих ко многим, то реляционная модель может быть лучше, 
	тк иначе код будет слишком сложным и медленным. В общем, все зависит от приложения и данных, с которыми работаем. 

Schema-on-read - схема при чтнии, структура данных неявна и их интерпретация происходит при чтении

Schema-on-write - схема при записи, традиционный подход реляционных бд, при котором есть явная схема и все данные ей соответствуют

Схемы в реляционных базах зачастую требуют миграции при изменении, а в документоориентированных бд это решается на уровне кода приложения. 

Схема при чтении лучше, если данные разнородные существуют разные тив объектов или структура сильно меняется со временем. 

Локальность данных даёт преимущество, если нужно получать большую часть документа сразу, но для загрузки даже фрагмента 
	нужно грузить весь документ, а при обновлении тоже переписывать его целиком, поэтому лучше минимизировать размеры документов 

Идея группировки родственных данных в целях локальности присутствует и в реляционной модели, напр, в бд spanner от гугла, 
	где можно объявить о необходимости вложенности строк таблицы внутри родительской. 
	В Oracle можно достичь того же при помощи многотабличных кластеризованных индекс таблиц. 
	В модели данных Bigtable в cassandra и hbase исп идея семейства столбцов. 

Большинство современных СУБД, кроме mysql уже могут работать с json и xml документами. 

Постепенно документоориентированные и реляционные модели сближаются, будущее скорее всего за их гибридом. 

Декларативныый язык - что хотим сделать, императивный - как хотим сделать. Декларативные языки скрывают внутренности реализации ядра бд, 
	и СУБД может повышать производительность без изменения запросов, а также хороши для параллельного выполнения. 

MapReduce - модель программирования для обработки больших объёмов данных блоками на множестве машин, продвигаемая гуглом. 
	Поддерживается частично в mongo и couch. По сути описывает функцию map, которая вызывается для каждой записи и функцию reduce, 
	которая группирует полученное. Это модель довольно низкого уровня, предназначенная для распределенных вычислений на кластерах 
	машин. Минус - приходится создавать две тщательно согласованные функции, что сложнее, чем писать один запрос, 
	и меньше возможностей оптимизации

Графовая модель данных - ок, если часто встречаются связи много ко многим. 

Модель графа свойств - ркалищованатв СУБД neo4j, titan, indinitegraph. Каждая вершина состоит из айдишник, 
	множеств исходящих и входящих рёбер и коллекции свойств ключ-значение. Каждое ребро состоит из айдишника, 
	начальной и конечной вершин и коллекции свойств ключ - значение. 

Хранилище можно представить в виде двух таблиц - одна для вершин, другая для рёбер. 

- любая вершина может быть соединена ребром с другой
- для любой вершины можно найти входящие и исходящие ребра, сделать обход графа
- используя разные метки для разных видов связей, можно хранить в одном графе несколько разных видов инфы, сохраняя чистоту модели

Модели получаются очень гибким и открытыми для расширения - можно легко расширить граф с учётом изменения в данных приложения. 

Cypher - Декларативныый язык запросов для графов свойств для бд Neo4j

Можно представлять графовые данные в виде реляционных таблиц и делать запросы на sql, хоть и не без проблем. 
	В реляционных бд нужные для запроса соединения обычно известны заранее, а в графовом запросе может понадобиться 
	обойти некоторое число рёбер, прежде чем будет найдена искомая вершина, те кол-во соединений заранее не фиксирована. 
	Можно исп рекурсивные обобщенные табличные выражения через with recursive, но запрос будет длинным и довольно неуклюжим. 

Модель хранилища тройных кортежей (triple store) - бд datomic, allegrograph. Практически эквивалентна модели графов свойств. 
	Вся инфа хранится в виде трехкомпонентных высказываний (субъект, предикат и объект). 
	Субъект - вершина, объект - либо значение простого типа, в этом случае предикат и объект эквивалентны ключу и значению 
	свойства вершины-субъекта, либо другая вершина графа. Тогда предикат - ребро, субъект - начальная вершина, 
	объект - конечная вершина. 

Resource description framework (rdf) - фреймворке описания ресурсов был задуман, как механизм публикации данных разными сайтами 
	в одном формате, благодаря чему данные с них могли бы объединяться в паутину данных - общую базу данных интернета. 

Язык запросов sparql - язык запросов для тройных кортежей, использующих модель данных rdf. Предшествовал Cypher. 

Отличия графовых баз от сетевых:
- в сетевой есть схема, определяющая данные, в графовых любая вершина может быть соединена с любой другой 
- в сетевой нельзя взять отдельный узел по айдишнику
- в графовой бд ребра и вершины не упорядочены
- большинство графовых бд поддерживают высокоуровневые языки запросов. 

Datalog - более старый язык, чем Cypher и sparql, фундамент для остальных языков запросов. Исп в немногих системах, 
	cascalog - развитие языка, исп в hadoop. Модель данных аналогична модели хранилищ тройных кортежей.