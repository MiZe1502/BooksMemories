Секционирование = шардинг (монго, эластик) = партицирование = сегментирование

Каждая секция по сути - отдельная бд

Цель - масштабируемость

Секционирование + репликации - каждая конкретная запись относится только к одной секции, но хранится на нескольких узлах для 
	отказоустойчивости. Для каждой секции один из узлов назначается ведущим.

Секционирование должно выполняться симметрично, те на одни секции не должно приходиться сильно больше нагрузки, чем на другие, 
	тк в этом случае эффективность секционирования падает.

Секция с не пропорционально высокой нагрузкой называется горячей точкой (Hot spot). Проще всего избежать этого - 
	назначать узлы для записи случайным образом. Другой способ - секционировать по диапазонам значений ключа, как в томах энциклопедии 

Для избежания асимметрии и горячих точке исп для распределения ключей по секциям хеш функцию. 
	На выходе получается равномерно распределенные значения. 

Всё равно могут возникать асимметричные нагрузки из-за особенностей данных, и тогда резолв таких проблем - обязанность приложения.

При наличии вторичных индексов секционирование становится сложным. Невозможно поставить вторичным индексам в чёткое соответствие секции. 
	В этом случае исп два подхода:
- секционирование по документам - каждая секция самостоятельна со своими вторичными индексами, но придётся делать запрос по всем секциям. 
- секционирование по термам - делаем глобальный индекс, охватывающий все секции, и его тоже секционируем и храним по секциям. 
	Плюсы - производительность чтения выше, тк запрос идёт только секции с нужным термом. Минус - запись сложнее и медленнее, 
	тк может затронуть несколько секций, и нужно исп распределенные транзакции. На практике обновления индексов происходят асинхронно.

Со временем требуется перебалансировка - перемещение нагрузки с одного узла на другой - из-за того, 
	что со временем распределение данных по секциям меняется, как и нагрузка, требуется больше ОЗУ, хардов и тд.

Методы перебалансировки:
- фиксированной количество секций - создаём намного больше секций, чем узлов и распределяем по несколько секций на узел. 
	Тогда новый узел берет по несколько секций у старых узлов, пока распределение не станет равномерным. 
	Это исп в riak, Elasticsearch, couchbase и voldemort. Минус - сложно добиться идеального размера секций
- динамическое секционирование - исп для секционирования по диапазонам ключей, в hbase и rethinkdb. 
	Когда размер секции превышает заданную величину, она бьётся на две примерно пополам. И наоборот, если секция становится меньше, 
	то её можно слить с другой. После разбиения секцию можно переместить в другой узел. 
	Плюс - адаптация количества секций к объёму данных. Минус - все начинается с одной секции и одного узла, 
	поэтому монго и hbase исп предразбиение для минимизации этого фактора.
- секционирование пропорционально количеству узлов - исп в cassandra и ketama. На каждый узел приходится фиксированное количество секций. 
	Новый узел выбирает ряд секций для разбиения, оставляя вторые половины на месте.

Маршрутизация запросов:
- резрешить клиентам обращаться к любому узлу, напр, с помощью балансировщика запросов или случайным  образом 
- отправлять все запросы сперва маршрутизатору, а тот уже решает какому узлу перенаправить запрос
- клиенты учитывают секционирование и распределение секций по узлам

Но в любом случае отвечающий за маршрутизацию компонент должен знать, где какая секция хранится и об изменении в распределении секций 
	по узлам. Многие системы исп отдельный сервис координации, напр, zookeeper.