Два пути распределения базы данных по нескольким машинам:
- масштабируемость
- отказоустойчивость, высокая доступность
- задержка - серверы как можно ближе к юзерам

Вертикальное масштабирование - более мощная машина

Горизонтальное масштабирование - архитектура без разделения ресурсов, много машин, каждая машина называется узлом.

Репликация - копии одних и тех же данных хранятся на нескольких разных узлах. Плюсы 'избыточность и повышение производительности
Секционирование - разбиение большой базы на небольшие части.

Эти механизмы часто сопутствуют друг другу.

Плюсы репликации:
- храним данные географически ближе к юзерам, сокращаются задержки
- система может работать при отказе некоторых её частей
- горизонтальное масштабирование и таким образом повышение пропускной способности по чтению.

Узлы, в которых хранятся копии бд, называются репликами.

Алгоритмы репликации изменений между узлами:
- с одним ведущим узлом - одна из реплик назначается ведущим узлом, клиенты отправляют запросы ему, и он пишет данные в локальную базу 
	и отправляет данные другим репликам. Остальные реплики - ведомые, обновляют свою локальную копию, 
	применяя все операции записи в порядке обработки ведущим узлом. Запросы на чтение разрешено отправлять всем узлам, 
	на запись - только ведущему. Такой режим - дефолтный во многих бд, напр, в постгресе
- с несколькими ведущими узлами
- без ведущего узла

Реплики могут выполняться синхронно или асинхронно. При синхронной репликации ведущий узел ждёт подтверждения 
	и только затем уведомляет клиента об успехе. При асинхронной ответ от ведомого узла не ожидается. 
	При синхронной репликации больше задержка, но зато копия всегда актуальна. Минус - если ведомый узел не отвечает, 
	то операцию завершить не удастся. Обычно делают один узел синхронныйм, остальные - асинхронными. 
	Такая гарантия называется полусинхронной. 

При добавлении нового ведомого узла при его создании используют снимок состояния ведущего узла, а затем запрашивают с него все данные, 
	появившиеся с момента снимка, т.о. ведомая нода наверстывает упущенное. 

При восстановлении ведомый узел запрашивает у ведущего все транзакции после последней применённой в своём журнале. 

При отказе ведущего один из ведомых становится ведущим и клиенты начинают слать данные ему. 
	Обычно ведущим становится узел с самыми свежими данными, согласование идёт через процесс консенсуса. 

При восстановлении есть множество проблем:
- при асинхронной репликации могут теряться данные или может быть конфликт и данные обычно отбрасываются 
- может появиться два ведущих узла 
- долгое время простоя до появления нового ведущего узла 

Операторная репликации - ведущий узел ведёт журнал операция, и по нему ведомые узлы копируют операции. 
	Но есть сложности с недетерминированными значениями, напр, ранд или получение текущего времени, 
	и с операторами с побочными действиями, напр, с триггерами. Поэтому исп другие методы, напр, перенос журнала упреждающей записи. 
	Этот метод используется в постгресе и оракле. Минус - тесное связывание репликации с системой хранения. 
	Альтернатива - разные форматы журнала репликации и подсистемы хранения. Такой вид журнала репликации называется логическим, 
	чтобы различать с физическим представлением системы хранения. Так проще поддерживать обратную совместимость 
	и проще читать журнал внешними приложениями. Для ещё большей гибкости можно исп триггеры для репликации. 
	Минусы - больше накладных расходов и сильнее подвержена ошибкам.

Масштабируемая по чтению архитектура (read scaling architecture) - если много запросов на чтение, и мало на запись, 
	отправляем запросы на чтение по многим ведомым узлам, разгружая ведущий узел. 
	Но этот подход работает только при асинхронной репликации, тк один вышедший из строя ведомый узел при синхронной репликации 
	делает всю систему недоступной для записи.

Задержка репликации - задержка между операцией записи на ведущем узле и её воспроизведением на ведомом.

Конечная согласованность - эффект, при котором несогласованность рано или поздно будет ликвидирована, 
	например если просто прекратить запись в бд и подождать

Чтение своих записей (read-your-writes) - при записи и последующем чтении этих данных с реплики, юзер может не получить их, 
	тк данные не доехали до реплики с ведущего узла. Для предотвращения этого данные юзера читают с ведущего узла, 
	а остальные - с ведомых или смотрят по времени обновления и читают с ведущего, и тд. Вариантов много.

Вторая аномалия - при двух запросах второй запрос видит более старые данные, тк запросы идут к разным репликам и данные ещё не 
	синхронизированы. В этом случае применяют монотонное чтение, напр, когда все пользователи читают из одной и той же реплики.

Согласованное префиксное чтение - гарантирует, что если операции записи выполняются в опред порядке, 
	то в том же порядке они будут прочитаны.

Один ведущий узел плох тем, что через него проходят все записи и при проблемах на этом узле будут проблемы с записью в бд для всей системы.

Поэтому иногда исп репликацию с несколькими ведущими узлами. (multi-leader). Каждый из ведущих узлов является одновременно ведомым 
	для других ведущих. Обычно такую схему исп с несколькими ЦОДами, и тогда ведущий узел будет в каждом ЦОДе => меньше задержки, 
	лучше производительность, больше устойчивость к отказам и проблемам с сетью. 
	Минус - нужно разрешать конфликты при изменении данных в разных цодах. 
	К репликации с несколькими ведущими узлами относятся и приложения, которые должны продолжать работать без инета, 
	например, календарь на телефоне, исп локальную бд.

Главная сложность - разрешение конфликтов при одновременном редактировании данных на ведущих узлах разных цодов и последующей 
	синхронизации.

Предотвращение конфликтов - самый простой способ, частично делаем репликацию с одним ведущим узлом тем или иным способом.

Сходимость к согласованному состоянию - в итоге все базы в репликах должны сойтись к одному состоянию. Способы:
- каждой операции даём уникальный айдишник и выбираем в итоге операцию с максимальным значением. Даннные могут теряться
- дать репликам айдишники и считать, что у репликов с большими айдишникми больший приоритет
- как-то сканкатенировать данные
- разрешать конфликты через код приложения

Топология репликации описывает пути, по которым операции записи распространяются с одного узла на другой:
- кольцо - движение по кругу от одного узла к другому 
- звезда - узел в центре и остальные связаны только с ним
- каждый с каждым

Кольцо и звезда плохо, тк отказ даже одного узла может прервать поток сообщений, но в каждый с каждым могут возникать гонки.

Существует подход репликации без ведущего узла, когда все узлы могут принимать операции записи. Такое исп, напр, в dynamo от Amazon, 
	в riak, cassandra и voldemort. В такой схеме нет восстановления после отказа, оно не нужно.

Если w - количество узлов, подтвердивших запись, n - общее кол-во узлов, r - кол-во узлов для каждой операции чтения, 
	то операции чтения и записи, удовл условия w + r > n, будут называться операциями чтения и записи по кворуму. 
	r и w по сути, это минимальное кол-во голосов, чтобы признать операцию приемлемой. 

Две операции записи конкурентны, если не знают друг о друге. 

Методы резолва конфликтов:
- выигрывает последний, отбраковываем конкурентные операции записи.
- обнаружение по номерам версий ключей 
- слияние родственных значений
- версии реплик (вектора версий)