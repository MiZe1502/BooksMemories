Плавающее обновление, или поэтапное развёртывание - новая версия развёртывается на нескольких узлах за раз и проверяется, 
	работает ли без проблем, а затем уже переходит на все узлы. Таким образом нет простоя сервиса. 

Старые и новые версии кода потенциально могут существовать в системе в один момент времени. 

Обратная совместимость - более новый код способен читать данные, записанные более старым

Прямая совместимость - более старый код способен читать данные, записанные более новым. 

Кодирование (encoding), или сериализация, маршалинг - преобразование из представления в памяти в последовательность байтов. 
	Обратная операция - декодирование, парсинг, десериализация или демаршаллинг. 

Json, xml, csv - текстовые форматы, понятны человеку, просты, но занимают много места, что привело к появлению двоичных версий, 
	напр, bson, bjson, wbxml и тд., но в них читается удобочитаемость для людей. 

В целом двоичных данные дают уменьшение объёма, но при маленьких объёмах выгоды мало. 

Protocol buffers и thrift - библиотеки двоичного кодирования, одна от Гугл, другая от фейсбука. Принцип одинаковый, описывается схема, 
	а затем при помощи утилиты генерятся классы для кодирования и декодирования.

Avro - двоичный формат, применяет схему для задания кодируемых данных, есть два языка описания схемы - один для редактирования людьми, 
	другой - для считывания компами. Компактнее в закодированном виде, чем протобаф и thrift. 
	В Avro есть схема для записи - для кодирования, и схема для чтения - для декодирования. 
	Схемы не обязательно должны совпадать достаточно, чтоб они были совместимы. 

Avro больше направлен на динамически генерируемые схемы, в нем нет номеров тегов. 

Существует множество путей движения данных из одного процесса в другой:
- через бд
- через вызов сервисов, напр, rest
- путем передачи асинхронных сообщений 

Поток данных через бд - записывающий процесс кодирует данные, читающий - декодирует. Может быть ситуация, 
	когда записано значение более новой версией кода, считано более старой, обновлено и снова записано. 
	Более новые поля могут потеряться при записи, и их сохранение нужно предусмотреть на уровне приложения.

Время жизни данных превышает время жизни кода - в базе могут быть и очень старые данные, кодированные очень старыми версиями кода. 
	Можно обновлять схему через миграции, но обычно это ресурсоемкая операция в случае большого количества данных, 
	и этого стараются не делать.

Дампы данных обычно делают с последней самой свежей версией схемы, чтобы было единообразно.

Поток данных через сервисы - REST и RPC - данные идут через веб сервисы, соответственно используя или soap со сгенерированным wsdl 
	для сервисов, либо рест апи.

Веб сервисы - это развитие длинной череды технологий выполнения запросов к апи по сети (java beans, dcom, corba и тд). 
	Всё они основаны на понятии удалённого вызова процедуры, кот состоит в том, 
	что выполнение запроса к удалённому сервису должно выглядить так же, как вызов обычного методы языка. 
	Эта абстракция называется независимостью от расположения (location transparency).

У RPC есть ряд минусов:
- непредсказуемость результата - могут быть проблемы на сети или в удалённом сервисе.
- может произойти возврат, но без результата в следствие превышения таймаута
- требуется поддержка идемпотентности пр повторной отправке запросов
- медленнее локальных вызовов
- данные передаются только через кодирование, нельзя передавать ссылки на объекты 

Подход рест апи тем и хорош, что он не делает вызовы удалённых процедур похожими на локальные. Но RPC все равно широко используется, 
	напр, в thrift и Avro, grpc - основан на протобафе.

Rest в основном исп для общедоступных апи, а RPC используется для запросов между сервисами внутри организации.

Поток данных передачи сообщений - сообщения отправляются асинхронно через брокер сообщений или очередь или какое-то иное по 
	для обработки сообщений.

Плюсы брокера:
- служит буфером в случае недоступности получателя
- автоматически отправляет сообщения сбойным процессам
- отправителю не нужно знать айпи адрес
- можно отправлять нескольким получателям

Зачастую это односторонее взаимодействие, в отличие от RPC, отправитель не ждёт ответа на свое сообщение.

Акторная модель (actor model) - модель программирования для создания коркурентного доступа в пределах одного процесса. 
	Логика инкапсулируется в акторах, которые соотв клиентам или сущностям,и у них могут быть свои локальные состояния. 
	Каждый актор одновременно обрабатывает одно сообщения, нет нужды заботиться о потоках выполнения и блокировках. 
	Допускается потеря сообщений. Распределенные акторные фреймворки объединяют в себе брокер сообщений и 
	акторную модель программирования. Примеры - akka, orleans и erlang otp.